## 线程之间的通信

```
我对线程通信的理解，
当我们需要多个线程来共同完成一件任务，并且希望它们有规律执行一件任务，并且我们希望它们有规律的执行，那么多线程之间需要一些通信机制，可以协调他们的工作，以此实现多线程共同操作一份数据
```

案例

```
比如线程a用来生产包子，线程b用来吃包子，包子就可以理解为同一资源，线程a与线程b处理的动作，一个是生产 一个是消费，此时线程b必须等到a线程完成后才能执行，线程a与线程b之间就需要线程通信，这就是等待唤醒机制
```



等待唤醒机制

这是多个线程之间的一种协作机制。谈到线程我老能想到线程之间的竞争，去争夺锁，但是线程之间也有协作机制。

```
在一个线程满足某个条件时，就进入等待状态（wait() \ wait(time)），等待其他线程执行完它们的代码过后再将其唤醒（notify()），也可以指定wait的时间，等时间到了自动唤醒；再有多个线程进行等待时，如果情况需要可以使用（notifyAll()）唤醒所有的等待线程。wait\notify就是线程间的一种协作机制。
```

```
wait：线程不再活动，不再参与调度，进入 `wait set` 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个`特别的动作`，也即“`通知（notify）`”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（`ready queue`）中

notify：则选取所通知对象的 wait set 中的一个线程释放；

notifyAll：则释放所通知对象的 wait set 上的全部线程。
```

```
等待唤醒机制可以解决生产者和消费者的问题，又叫有限缓冲问题
是个多线程经典的问题，描述两个及以上的共享固定缓冲大小的线程
生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。**该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。**

举例：

生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

类似的场景，比如厨师和服务员等。

生产者与消费者问题中其实隐含了两个问题：

线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。

线程的协调工作问题：
要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。
```

